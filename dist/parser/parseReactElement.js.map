{"version":3,"sources":["../../src/parser/parseReactElement.js"],"names":["getReactElementDisplayName","element","type","displayName","name","noChildren","propsValue","propName","onlyMeaningfulChildren","children","filterProps","originalProps","cb","filteredProps","Object","keys","filter","key","forEach","parseReactElement","options","displayNameFn","value","Error","props","ref","search","defaultProps","childrens","toArray","map","child"],"mappings":";;;;;;;;AAEA;;AAIA,IAAMA,6BAA6B,SAA7BA,0BAA6B,CAACC,OAAD;AAAA,SACjCA,QAAQC,IAAR,CAAaC,WAAb,IACAF,QAAQC,IAAR,CAAaE,IADb,MACqB;AACpB,SAAOH,QAAQC,IAAf,KAAwB,UAAxB,CAAmC;AAAnC,IACG,iBADH,GAEGD,QAAQC,IAJZ,CADiC;AAAA,CAAnC;;AAOA,IAAMG,aAAa,SAAbA,UAAa,CAACC,UAAD,EAAaC,QAAb;AAAA,SAA0BA,aAAa,UAAvC;AAAA,CAAnB;;AAEA,IAAMC,yBAAyB,SAAzBA,sBAAyB,CAACC,QAAD;AAAA,SAC7BA,aAAa,IAAb,IACAA,aAAa,KADb,IAEAA,aAAa,IAFb,IAGAA,aAAa,EAJgB;AAAA,CAA/B;;AAMA,IAAMC,cAAc,SAAdA,WAAc,CAACC,aAAD,EAAoBC,EAApB,EAAqD;AACvE,MAAMC,gBAAgB,EAAtB;;AAEAC,SAAOC,IAAP,CAAYJ,aAAZ,EACGK,MADH,CACU;AAAA,WAAOJ,GAAGD,cAAcM,GAAd,CAAH,EAAuBA,GAAvB,CAAP;AAAA,GADV,EAEGC,OAFH,CAEW;AAAA,WAAQL,cAAcI,GAAd,IAAqBN,cAAcM,GAAd,CAA7B;AAAA,GAFX;;AAIA,SAAOJ,aAAP;AACD,CARD;;AAUA,IAAMM,oBAAoB,SAApBA,iBAAoB,CACxBlB,OADwB,EAExBmB,OAFwB,EAGX;AAAA,6BACuDA,OADvD,CACLjB,WADK;AAAA,MACQkB,aADR,wCACwBrB,0BADxB;;AAEb,MAAME,cAAcD,OAAd,yCAAcA,OAAd,CAAN;;AAEA,MAAIC,SAAS,QAAT,IAAqBA,SAAS,QAAlC,EAA4C;AAC1C,WAAO;AACLA,gBADK;AAELoB,aAAOrB;AAFF,KAAP;AAID,GALD,MAKO,IAAI,CAAC,2BAAeA,OAAf,CAAL,EAA8B;AACnC,UAAM,IAAIsB,KAAJ,0EACmEtB,OADnE,yCACmEA,OADnE,SAAN;AAGD;;AAED,MAAME,cAAckB,cAAcpB,OAAd,CAApB;;AAEA,MAAMuB,QAAQd,YAAYT,QAAQuB,KAApB,EAA2BnB,UAA3B,CAAd;AACA,MAAIJ,QAAQwB,GAAR,KAAgB,IAApB,EAA0B;AACxBD,UAAMC,GAAN,GAAYxB,QAAQwB,GAApB;AACD;;AAED,MAAMR,MAAMhB,QAAQgB,GAApB;AACA,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,IAAIS,MAAJ,CAAW,KAAX,CAA/B,EAAkD;AAChD;AACAF,UAAMP,GAAN,GAAYA,GAAZ;AACD;;AAED,MAAMU,eAAejB,YAAYT,QAAQC,IAAR,CAAayB,YAAb,IAA6B,EAAzC,EAA6CtB,UAA7C,CAArB;AACA,MAAMuB,YAAY,gBAASC,OAAT,CAAiB5B,QAAQuB,KAAR,CAAcf,QAA/B,EACfO,MADe,CACRR,sBADQ,EAEfsB,GAFe,CAEX;AAAA,WAASX,kBAAkBY,KAAlB,EAAyBX,OAAzB,CAAT;AAAA,GAFW,CAAlB;;AAIA,SAAO;AACLlB,UAAM,cADD;AAELC,4BAFK;AAGLqB,gBAHK;AAILG,8BAJK;AAKLC;AALK,GAAP;AAOD,CA3CD;;kBA6CeT,iB","file":"parseReactElement.js","sourcesContent":["/* @flow */\n\nimport { Children, Element, isValidElement } from 'react';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst getReactElementDisplayName = (element: Element<*>): string =>\n  element.type.displayName ||\n  element.type.name || // function name\n  (typeof element.type === 'function' // function without a name, you should provide one\n    ? 'No Display Name'\n    : element.type);\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: Element<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n  const type = typeof element;\n\n  if (type === 'string' || type === 'number') {\n    return {\n      type,\n      value: element,\n    };\n  } else if (!isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps,\n    childrens,\n  };\n};\n\nexport default parseReactElement;\n"]}