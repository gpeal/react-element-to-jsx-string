{"version":3,"sources":["../../src/formatter/formatReactElementNode.js"],"names":["recurse","lvl","inline","options","element","onlyPropsWithOriginalValue","defaultProps","props","haveDefaultValue","Object","keys","includes","propName","isInlineAttributeTooLong","attributes","inlineAttributeString","tabStop","maxInlineAttributesLineLength","length","shouldRenderMultilineAttr","containsMultilineAttr","node","type","displayName","childrens","Error","filterProps","showDefaultProps","sortProps","out","outInlineAttr","outMultilineAttr","visibleAttributeNames","filter","indexOf","forEach","push","defaultPropName","sort","attributeName","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","newLvl","reduce","map","join"],"mappings":"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","file":"formatReactElementNode.js","sourcesContent":["/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport propNameSorter from './propNameSorter';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst recurse = (lvl: number, inline: boolean, options: Options) => element =>\n  formatTreeNode(element, inline, lvl, options);\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens = [],\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  Object.keys(props)\n    .filter(propName => filterProps.indexOf(propName) === -1)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(defaultPropName => filterProps.indexOf(defaultPropName) === -1)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = visibleAttributeNames.sort(propNameSorter(sortProps));\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(recurse(newLvl, inline, options))\n      .join(`\\n${spacer(newLvl, tabStop)}`);\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n"]}